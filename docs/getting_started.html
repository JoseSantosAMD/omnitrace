<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Getting Started &mdash; omnitrace 1.7.1 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Configuring Omnitrace Runtime" href="runtime.html" />
    <link rel="prev" title="Setup and Validation" href="setup.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> omnitrace
          </a>
              <div class="version">
                1.7.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="setup.html">Setup and Validation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#nomenclature">Nomenclature</a></li>
<li class="toctree-l2"><a class="reference internal" href="#general-tips">General Tips</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-collection-mode-s">Data Collection Mode(s)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#binary-instrumentation">Binary Instrumentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statistical-sampling">Statistical Sampling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-instrumentation-vs-statistical-sampling-example">Binary Instrumentation vs. Statistical Sampling Example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#binary-instrumentation-of-fibonacci-function">Binary Instrumentation of Fibonacci Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#statistical-sampling-of-fibonacci-function">Statistical Sampling of Fibonacci Function</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="runtime.html">Configuring Omnitrace Runtime</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">Call-Stack Sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="instrumenting.html">Binary Instrumentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="critical_trace.html">Generating a Critical Trace</a></li>
<li class="toctree-l1"><a class="reference internal" href="output.html">Omnitrace Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_api.html">User API</a></li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="youtube.html">YouTube Tutorials</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">omnitrace</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Getting Started</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/getting_started.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<style>
em { color: Green; }
</style><div class="section" id="nomenclature">
<h2>Nomenclature<a class="headerlink" href="#nomenclature" title="Permalink to this headline">¶</a></h2>
<p>The list provided below is intended to (A) provide a basic glossary for those who are not familiar with binary instrumentation, etc. and (B)
provide clarification to ambiguities when certain terms have different contextual meanings,
e.g., omnitrace’s meaning of the term “module” when instrumenting Python.</p>
<ul class="simple">
<li><p><strong>Binary</strong></p>
<ul>
<li><p>File written in the Executable and Linkable Format (ELF)</p></li>
<li><p>Standard file format for executable files, shared libraries, etc.</p></li>
</ul>
</li>
<li><p><strong>Binary Instrumentation</strong></p>
<ul>
<li><p>Inserting callbacks to instrumentation into an existing binary. This can be performed statically or dynamically</p></li>
</ul>
</li>
<li><p><strong>Static Binary Instrumentation</strong></p>
<ul>
<li><p>Loads an existing binary, determines instrumentation points, and generates a new binary with instrumentation directly embedded</p></li>
<li><p>Applicable to executables and libraries but limited to only the functions defined in the binary</p></li>
<li><p>Also known as: <strong>Binary Rewrite</strong></p></li>
</ul>
</li>
<li><p><strong>Dynamic Binary Instrumentation</strong></p>
<ul>
<li><p>Loads an existing binary into memory, inserts instrumentation, executes binary</p></li>
<li><p>Limited to executables but capable of instrumenting linked libraries</p></li>
<li><p>Also known as: <strong>Runtime Instrumentation</strong></p></li>
</ul>
</li>
<li><p><strong>Statistical Sampling</strong></p>
<ul>
<li><p>Also known as (simply) “sampling”</p></li>
<li><p>At periodic intervals, the application is paused and the current call-stack of the CPU is recorded alongside with various other metrics</p></li>
<li><p>Uses timers that measure either (A) real clock time or (B) the CPU time used by the current thread and the CPU time expended on behalf of the thread by the system</p></li>
<li><p><strong>Sampling Rate</strong></p>
<ul>
<li><p>The period at which (A) or (B) are triggered (in units of <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">interrupts</span> <span class="pre">/</span> <span class="pre">second</span></code>)</p></li>
<li><p>Higher values increase the number of samples</p></li>
</ul>
</li>
<li><p><strong>Sampling Delay</strong></p>
<ul>
<li><p>How long to wait before (A) and (B) begin triggering at their designated rate</p></li>
</ul>
</li>
<li><p><strong>Sampling Duration</strong></p>
<ul>
<li><p>The time (in realtime) after the start of the application to record samples. Once this time limit has been reached, no more samples will be recorded.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Process Sampling</strong></p>
<ul>
<li><p>At periodic (realtime) intervals, a background thread records global metrics without interrupting the current process. These metrics include, but are not limited to: CPU frequency,
CPU memory high-water mark (i.e. peak memory usage), GPU Temperature, GPU Power usage, etc.</p></li>
<li><p><strong>Sampling Rate</strong></p>
<ul>
<li><p>The realtime period for recording metrics (in units of <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">measurements</span> <span class="pre">/</span> <span class="pre">second</span></code>)</p></li>
<li><p>Higher values increase the number of samples</p></li>
</ul>
</li>
<li><p><strong>Sampling Delay</strong></p>
<ul>
<li><p>How long to wait (in realtime) before recording samples</p></li>
</ul>
</li>
<li><p><strong>Sampling Duration</strong></p>
<ul>
<li><p>The time (in realtime) after the start of the application to record samples. Once this time limit has been reached, no more samples will be recorded.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Module</strong></p>
<ul>
<li><p>With respect to binary instrumentation, a module is defined as either the filename (e.g. <code class="docutils literal notranslate"><span class="pre">foo.c</span></code>) or library name (<code class="docutils literal notranslate"><span class="pre">libfoo.so</span></code>) which contains the definition of one or more functions</p></li>
<li><p>With respect to Python instrumentation, a module is defined as the <em>file</em> which contains the definition of one or more functions.</p>
<ul>
<li><p>The full path to this file <em>typically</em> contains the name of the “Python module”</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Basic Block</strong></p>
<ul>
<li><p>Straight-line code sequence with:</p>
<ul>
<li><p>No branches in (except for the entry)</p></li>
<li><p>No branches out (except for the exit)</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Address Range</strong></p>
<ul>
<li><p>The instructions for a function in a binary start at certain address with the ELF file and end at a certain address, the range is <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">-</span> <span class="pre">start</span></code></p></li>
<li><p>The address range is a decent approximation for the “cost” of a function, i.e., a larger address range approx. equates to more instructions</p></li>
</ul>
</li>
<li><p><strong>Instrumentation Traps</strong></p>
<ul>
<li><p>On the x86 architecture, because instructions are of variable size, the instruction at a point may be too small for Dyninst to replace it with the normal code sequence used to call instrumentation</p>
<ul>
<li><p>Also, when instrumentation is placed at points other than subroutine entry, exit, or call points, traps may be used to ensure the instrumentation fits</p></li>
</ul>
</li>
<li><p>By default, omnitrace avoids instrumentation which requires using a trap</p></li>
</ul>
</li>
<li><p><strong>Overlapping functions</strong></p>
<ul>
<li><p>Due to language constructs or compiler optimizations, it may be possible for multiple functions to overlap (that is, share part of the same function body) or for a single function to have multiple entry points</p></li>
<li><p>In practice, it is impossible to determine the difference between multiple overlapping functions and a single function with multiple entry points</p></li>
<li><p>By default, omnitrace avoids instrumenting overlapping functions</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-tips">
<h2>General Tips<a class="headerlink" href="#general-tips" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><em><strong>Use <code class="docutils literal notranslate"><span class="pre">omnitrace-avail</span></code> to lookup configuration settings</strong></em>, hardware counters, and data collection components</p>
<ul>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">-d</span></code> flag for descriptions</p></li>
</ul>
</li>
<li><p>Generate a default configuration with <code class="docutils literal notranslate"><span class="pre">omnitrace-avail</span> <span class="pre">-G</span> <span class="pre">${HOME}/.omnitrace.cfg</span></code> and tweak accordingly to the desired default behavior</p></li>
<li><p><em><strong>Decide whether binary instrumentation, statistical sampling, or both</strong></em> will provide the desired performance data (for non-Python applications)</p></li>
<li><p>Compile code with optimization enabled (e.g. <code class="docutils literal notranslate"><span class="pre">-O2</span></code> or higher), disable asserts (i.e. <code class="docutils literal notranslate"><span class="pre">-DNDEBUG</span></code>), and include debug info (i.e. <code class="docutils literal notranslate"><span class="pre">-g1</span></code> at a minimum)</p>
<ul>
<li><p>NOTE: compiling with debug info does not slow down the code, it only increases compile time and the size of the binary</p></li>
<li><p>In CMake, this is generally as easy as settings <code class="docutils literal notranslate"><span class="pre">CMAKE_BUILD_TYPE=RelWithDebInfo</span></code> or <code class="docutils literal notranslate"><span class="pre">CMAKE_BUILD_TYPE=Release</span></code> and <code class="docutils literal notranslate"><span class="pre">CMAKE_&lt;LANG&gt;_FLAGS=-g1</span></code></p></li>
</ul>
</li>
<li><p>Use <em><strong>binary instrumentation for characterizing the performance of every invocation of specific functions</strong></em></p></li>
<li><p>Use <em><strong>statistical sampling to characterize the performance of the entire application while minimizing overhead</strong></em></p></li>
<li><p>Enable statistical sampling after binary instrumentation to help “fill in the gaps” between instrumented regions</p></li>
<li><p>Use the user API to create custom regions, enable/disable omnitrace to specific processes, threads, and/or regions</p></li>
<li><p>Dynamic symbol interception, callback APIs, and the user API are always available with binary instrumentation and sampling</p>
<ul>
<li><p>Dynamic symbol interception and callback APIs are (generally) controlled through <code class="docutils literal notranslate"><span class="pre">OMNITRACE_USE_&lt;API&gt;</span></code> options, e.g. <code class="docutils literal notranslate"><span class="pre">OMNITRACE_USE_KOKKOSP</span></code>, <code class="docutils literal notranslate"><span class="pre">OMNITRACE_USE_OMPT</span></code> enable Kokkos-Tools and OpenMP-Tools callbacks, respectively</p></li>
</ul>
</li>
<li><p>When generically seeking regions for performance improvement:</p>
<ul>
<li><p><em><strong>Start off collecting a flat profile</strong></em></p></li>
<li><p>Look for functions with high call counts, large cumulative runtimes/values, and/or large standard deviations</p>
<ul>
<li><p>When call-counts are high, improving the performance of this function or “inlining” the function can be quick and easy performance improvements</p></li>
<li><p>When the standard-deviation is high, collect a hierarchical profile and see if the high variation can be attributable to the calling context. In this scenario, consider creating a specialized version for the function for the longer running contexts</p></li>
</ul>
</li>
<li><p><em><strong>Collect a hierarchical profile</strong></em> and, keeping the flat-profiling data in mind, verify the functions noted in the flat profile are part of the “critical path” of your application</p>
<ul>
<li><p>E.g. function(s) with high call counts, etc. which are part of a “setup” or “post-processing” phase which does not consume much time relative to the overall time is, generally, a lower priority for optimization</p></li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>Use the information from the profiles when analyzing detailed traces</strong></em></p></li>
<li><p>When using binary instrumentation in the “trace” mode, the <em><strong>binary rewrites are preferable to runtime instrumentation</strong></em>.</p>
<ul>
<li><p>Binary rewrites only instrument the functions defined in the target binary, whereas runtime instrumentation can/will instrument functions defined in the shared libraries which are linked into the target binary</p></li>
</ul>
</li>
<li><p>When using binary instrumentation with MPI, avoid runtime instrumentation</p>
<ul>
<li><p>Runtime instrumentation requires a fork + ptrace: which is generally incompatible with how MPI applications spawn their processes</p></li>
<li><p>Binary rewrite the executable using MPI (and, optionally, libraries used by the executable) and execute the generated instrumented executable instead of the original, e.g. <code class="docutils literal notranslate"><span class="pre">mpirun</span> <span class="pre">-n</span> <span class="pre">2</span> <span class="pre">./myexe</span></code> should be <code class="docutils literal notranslate"><span class="pre">mpirun</span> <span class="pre">-n</span> <span class="pre">2</span> <span class="pre">./myexe.inst</span></code> where <code class="docutils literal notranslate"><span class="pre">myexe.inst</span></code> is the generated instrumented <code class="docutils literal notranslate"><span class="pre">myexe</span></code> executable.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="data-collection-mode-s">
<h2>Data Collection Mode(s)<a class="headerlink" href="#data-collection-mode-s" title="Permalink to this headline">¶</a></h2>
<p>Omnitrace supports several modes of recording trace and profiling data for your application:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Mode</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td>Binary Instrumentation</td>
<td>Locates functions (and loops, if desired) in binary and inserts snippets at the entry and exit</td>
</tr>
<tr>
<td>Statistical Sampling</td>
<td>Periodically pauses application at specified intervals and records various metrics for the given call-stack</td>
</tr>
<tr>
<td>Callback APIs</td>
<td>Parallelism frameworks such as ROCm, OpenMP, and Kokkos will make callbacks into omnitrace to provide information about the work the API is performing</td>
</tr>
<tr>
<td>Dynamic Symbol Interception</td>
<td>Wrap function symbols defined in position independent dynamic library/executable, e.g. <code>pthread_mutex_lock</code> in libpthread.so or <code>MPI_Init</code> in the MPI library</td>
</tr>
<tr>
<td>User API</td>
<td>User-defined regions and controls for omnitrace</td>
</tr>
</tbody>
</table><p>The two most generic, important modes are binary instrumentation and statistical sampling. It is important to understand the advantages and disadvantages.
Binary instrumentation and statistical sampling can be performed with the <code class="docutils literal notranslate"><span class="pre">omnitrace</span></code> executable but for statistical sampling, it is highly recommended to use the
<code class="docutils literal notranslate"><span class="pre">omnitrace-sample</span></code> executable instead if no binary instrumentation is required/desired. With either tool, the callback APIs and dynamic symbol interception can be
utilized.</p>
<div class="section" id="binary-instrumentation">
<h3>Binary Instrumentation<a class="headerlink" href="#binary-instrumentation" title="Permalink to this headline">¶</a></h3>
<p>Binary instrumentation will allow one to deterministically record measurements for every single invocation of a given function.
Binary instrumentation effectively adds instructions to the target application to collect the required information and, thus, has the potential to cause performance changes which may,
in some cases, lead to inaccurate results. The effect depends on what information being collected and which features are activated in omnitrace. For example, collecting only the wall-clock timing data
will have less effect than collected the wall-clock timing, cpu-clock timing, memory usage, cache-misses, and number of instructions executed. Similarly, collecting a flat profile will have
less overhead than a hierarchical profile and collecting a trace OR a profile will have less overhead than collecting a trace AND a profile.</p>
<p>In omnitrace, the primary heuristic for controlling the overhead with binary instrumentation is the minimum number of instructions for selecting functions for instrumentation.</p>
</div>
<div class="section" id="statistical-sampling">
<h3>Statistical Sampling<a class="headerlink" href="#statistical-sampling" title="Permalink to this headline">¶</a></h3>
<p>Statistical call-stack sampling periodically interrupts the application at regular intervals using operating system interrupts.
Sampling is typically less numerically accurate and specific, but allows the target program to run at near full speed.
In constrast to the data derived from binary instrumentation, the resulting data is not exact but, instead, a statistical approximation.
However, sampling often provides a more accurate picture of the application execution because it is less intrusive to the target application and has fewer
side effects on memory caches or instruction decoding pipelines. Furthermore, since sampling does not affect the execution speed as significantly, is it
relatively immune to over-evaluating the cost of small, frequently called functions or “tight” loops.</p>
<p>In omnitrace, the overhead for statistical sampling is a factor of the sampling rate and whether the samples are taken with respect to the CPU time and/or real time.</p>
</div>
<div class="section" id="binary-instrumentation-vs-statistical-sampling-example">
<h3>Binary Instrumentation vs. Statistical Sampling Example<a class="headerlink" href="#binary-instrumentation-vs-statistical-sampling-example" title="Permalink to this headline">¶</a></h3>
<p>Consider for the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="nf">fib</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">nfib</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%li] fibonacci(%li) = %li</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">nfib</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">nfib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">nitr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">nfib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">nitr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nitr</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">run</span><span class="p">(</span><span class="n">nfib</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Binary instrumentation of the <code class="docutils literal notranslate"><span class="pre">fib</span></code> function will record <em><strong>every single invocation</strong></em> of the function – which for a very small function
such as <code class="docutils literal notranslate"><span class="pre">fib</span></code>, will result in <em>significant</em> overhead since this simple function tends to be less than 20 or so instructions, whereas the entry and
exit snippets are ~1024 instructions. Thus, <em><strong>we generally want to avoid instrumenting functions where the instrumented function has significantly fewer
instructions than entry + exit instrumentation</strong></em> (please note, however, that many of the instructions entry/exit functions are either logging functions or
depend on the runtime settins and thus may never be executed). However, due to the number of potentially executed instructions in the entry/exit snippets,
the default behavior of omnitrace is to only instrument functions which contain fewer than 1024 instructions.</p>
<p>However, recording every single invocation of the function can be extremely useful for detecting anomalies: profiles will show min/max values much smaller/larger
than the average and/or high standard deviation and traces will allow you to identify exactly when and where those instances deviated from the norm.
Consider the level of details in the following traces where, in the top image, every instance of the <code class="docutils literal notranslate"><span class="pre">fib</span></code> function was instrumented vs. the bottom image
where the <code class="docutils literal notranslate"><span class="pre">fib</span></code> call-stack was derived via sampling:</p>
<div class="section" id="binary-instrumentation-of-fibonacci-function">
<h4>Binary Instrumentation of Fibonacci Function<a class="headerlink" href="#binary-instrumentation-of-fibonacci-function" title="Permalink to this headline">¶</a></h4>
<p><img alt="instrumented-fibonnaci-trace" src="_images/fibonacci-instrumented.png" /></p>
</div>
<div class="section" id="statistical-sampling-of-fibonacci-function">
<h4>Statistical Sampling of Fibonacci Function<a class="headerlink" href="#statistical-sampling-of-fibonacci-function" title="Permalink to this headline">¶</a></h4>
<p><img alt="sampled-fibonnaci-trace" src="_images/fibonacci-sampling.png" /></p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="setup.html" class="btn btn-neutral float-left" title="Setup and Validation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="runtime.html" class="btn btn-neutral float-right" title="Configuring Omnitrace Runtime" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Advanced Micro Devices, Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1HLBBRSTT9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-1HLBBRSTT9', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>